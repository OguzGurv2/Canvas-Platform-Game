<!DOCTYPE html5>
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena Jumper</title>

<body>
    <canvas id="game-canvas"></canvas>     
    <div class="interface none">
        <div id="health">
            <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
                <path id="heart-icon" class="none" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/>
            </svg>
        </div>
        <p id="score">0</p>
    </div>
    <button id="start-button">Start</button>
</body>

<style>
    @import url('https://fonts.googleapis.com/css2?family=REM:wght@800&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

    * {
        box-sizing: border-box;
        padding: 0;
        margin: 0;
    }

    body {
        background: white;
    }

    :root {
        --text: #0b090a;
        --background: #f8f6f7;
        --primary: #678378;
        --secondary: #e0d7db;
        --accent: #678378;
    }

    canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 5px solid white;
        max-width: 100%;
        max-height: 100%;
        background-color: var(--background);
    }
    
    svg {
        width: 100%;
    }

    .interface {
        width: 100px;
        height: 50px;
        color: var(--text);
        display: flex;
        flex-direction: column;
        background: none;  
        position: absolute;
        left: 5%;   
    }

    #start-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--primary);
        color: var(--secondary);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        height: 50px;
        width: 100px;
        font-family: 'REM', sans-serif;
    }

    .interface p {
        margin-block: 5px;
    }

    .none {
        display: none;
    }

    </style>

<script>
    
    // const canvas = document.getElementById('game-canvas');
    // const ctx = canvas.getContext("2d");
    // canvas.height = 900;
    // canvas.width = 400;

    // const radius = Math.min(canvas.width, canvas.height) * 0.025;
    
    // const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary');
    // const text = getComputedStyle(document.documentElement).getPropertyValue('--text');

    // const interface = document.querySelector('.interface');
    // const startButton = document.querySelector('#start-button');
    
    // let score = 0;
    // const scoreUI = document.querySelector('#score');
    
    // const heartIcon = document.querySelector('#heart-icon');
    // const svg = document.querySelector('svg');
    
    // var isRunning = false;
    // let gravity = 0.1;
    // let jumpScore = 0;
    // let coinCount = 0;
    // let enemyCount = 0;
    // let hasCollided = false;
    
    // const camera = {
    //     y: 0,
    //     x: 0,
    //     width: canvas.width,
    //     height: canvas.height,
    // };
    
    // let lifeLeft = 3;
    // let jumpStrength = 3;
    // let jumpDuration = 20; 
    // let jumpFrame = 0;
    // let freezePlayer = false;
    // let trambolineUsed = false;
    // let isDragging = false;
    // let dragOffsetX = 0;
    
    // const player = {
    //     x: (canvas.width / 2) - 7.5,
    //     y: (canvas.height / 2) + 70, 
    //     width: 15,
    //     height: 30,
    //     speedY: 0,
    //     isJumping: false,
    //     isFlying: false,
    // };  
    
    // let spearOffset = 7.5;
    // const spear = {
    //     x: player.x - spearOffset,
    //     y: player.y - 20, 
    //     width: 5,
    //     height: 30,
    // };
    
    // let minValue;
    // var lowestPlatform;
    // const platformMoveStrength = 0.25;
    // const platformAnimDuration = 1000;
    // let platformAnimFrame = 0;
    // const particleMoveStrength = gravity * 10;

    // const platforms = [
    //     { id: 0, x: (canvas.width / 2) - 14, y: (canvas.height / 2) + 90, width: 25, height: 5 },
    //     { id: 1, x: (canvas.width / 2) + 175, y: (canvas.height / 2) - 46, width: 25, height: 5, booster: true },
    //     { id: 2, x: (canvas.width + 150) / 2, y: (canvas.height / 2) - 10, width: 50, height: 5 },
    //     { id: 3, x: (canvas.width - 75) / 2, y: (canvas.height / 2) - 90, width: 25, height: 5, coin: true },
    //     { id: 4, x: (canvas.width / 2 ) - 200, y: (canvas.height / 2) - 110, width: 25, height: 5, breakCount: 0 },
    //     { id: 5, x: (canvas.width + 200) / 2, y: (canvas.height / 2) - 130, width: 50, height: 5, heart: true },
    //     { id: 6, x: (canvas.width - 250) / 2, y: (canvas.height / 2) - 180, width: 25, height: 5,  isMoving: true, particle: true },
    //     { id: 7, x: (canvas.width + 100) / 2, y: (canvas.height / 2) - 210, width: 25, height: 5, tramboline: true },
    //     { id: 8, x: (canvas.width - 35) / 2, y: (canvas.height / 2) - 260, width: 25, height: 5,  isMoving: true },
    //     { id: 9, x: (canvas.width - 250) / 2, y: (canvas.height / 2) - 280, width: 25, height: 5 }, 
    //     { id: 10, x: (canvas.width + 190) / 2, y: (canvas.height / 2) - 310, width: 25, height: 5 },
    //     { id: 11, x: (canvas.width) / 2, y: (canvas.height / 2) - 400, width: 25, height: 5},
    //     { id: 12, x: (canvas.width - 100) / 2 , y: (canvas.height / 2) - 500, width: 50, height: 5 },
    //     { id: 13, x: (canvas.width - 200) / 2, y: (canvas.height / 2) - 600, width: 25, height: 5 },
    //     { id: 14, x: (canvas.width + 10) / 2, y: (canvas.height / 2) - 700, width: 25, height: 5 },
    //     { id: 15, x: (canvas.width + 50) / 2, y: (canvas.height / 2) - 800, width: 50, height: 5 },
    //     { id: 16, x: (canvas.width - 50) / 2, y: (canvas.height / 2) - 900, width: 25, height: 5 },
    //     { id: 17, x: (canvas.width - 75) / 2, y: (canvas.height / 2) - 1000, width: 25, height: 5 },
    //     { id: 18, x: (canvas.width - 350) / 2, y: (canvas.height / 2) - 1100, width: 50, height: 5 },
    // ];

    // const coinStats = {
    //     coinRadius: radius,
    //     coinStartAngle: 0, 
    //     coinEndAngle: Math.PI * 2
    // };

    // const assetStats = {
    //     width: 25, height: 25
    // };

    // const particleStats = {
    //     particleRadius: radius/2,
    //     particleStartAngle: 0, 
    //     particleEndAngle: Math.PI * 2,
    // };

    // let platformContainer = [];
    
    // let trambolineContainer = [];

    // let boosterContainer = [];

    // let coinContainer = [];

    // let enemyContainer = [];
    
    // let heartContainer = [];

    // let particleContainer = [];


    // function touchStart(event) {
    //     const tapX = event.touches[0].clientX - canvas.getBoundingClientRect().left;

    //     isDragging = true;
    //     dragOffsetX = player.x - tapX;
    //     offset = spear.x - player.x;
    // };

    // function touchMove(event) {
    //     if (isDragging && !freezePlayer) {
    //         const tapX = event.touches[0].clientX - canvas.getBoundingClientRect().left;

    //         player.x = tapX + dragOffsetX;
    //         spear.x = player.x - spearOffset;

    //         if (player.x < 0) {
    //             player.x += canvas.width;
    //             spear.x += canvas.width;
    //         } else if (player.x > canvas.width) {
    //             player.x -= canvas.width;
    //             spear.x -= canvas.width;
    //         };
    //     };
    // };

    // function touchEnd() {
    //     isDragging = false;
    // };

    // canvas.addEventListener('touchstart', touchStart, {passive: true});
    // canvas.addEventListener('touchmove', touchMove, {passive: true});
    // canvas.addEventListener('touchend', touchEnd, {passive: true});

    // function drawHeartIcons() {
    //     const cloneIcons = document.querySelectorAll('#clone');
    //     if (lifeLeft > 0) {
    //         cloneIcons.forEach((cloneIcon, index) => {
    //             if (index > 0) {
    //                 cloneIcon.parentNode.removeChild(cloneIcon);
    //             }
    //         });
    //         for (let index = 0; index < lifeLeft; index++) {
    //             const newIcon = heartIcon.cloneNode(true)
    //             newIcon.classList.remove('none');
    //             newIcon.id = 'clone';
    //             newIcon.setAttribute('transform', `translate(${550 * index - 1350})`);
    //             newIcon.setAttribute('fill', `red`);
    //             svg.appendChild(newIcon);
    //         };
    //     }; 
    // };

    // function clearCanvas() {
    //     ctx.clearRect(0, 0, canvas.width, canvas.height);
    // };

    // function drawPlayer() {
    //     ctx.fillStyle = text;
    //     ctx.fillRect(player.x, player.y - camera.y, player.width, player.height);
    //     ctx.fillRect(spear.x, spear.y - camera.y, spear.width, spear.height)
    // };
  
    // function drawPlatforms() {
    //     platformContainer.forEach(platform => {
    //         if (platform.breakCount) {
    //           ctx.fillStyle = 'brown';  
    //         } else {
    //             ctx.fillStyle = primary;
    //         };
    //         ctx.fillRect(platform.x, platform.y - camera.y, platform.width, platform.height);
    //     });
    // };

    // function movingPlatformAnim(platform) {
    //     if (platformAnimDuration > platformAnimFrame) {

    //         if (platform.particle) {
    //             particleAnim(platform);
    //         };

    //         if (platformAnimDuration / 2 <= platformAnimFrame) {
    //             platform.x += -platformMoveStrength ;
    //             platformAnimFrame++;
    //         } else {
    //             platform.x += platformMoveStrength;
    //             platformAnimFrame++;
    //         };
    //         if (platformAnimFrame === platformAnimDuration) {
    //             platformAnimFrame = 0;
    //         };
    //     };
    // };

    // function particleAnim(platform) {
    //     const foundParticle = particleContainer.find(particle => areEqual(particle, platform));
    //     foundParticle.y += particleMoveStrength;

    //     if (0 === platformAnimFrame) {
    //         foundParticle.y = platform.y;
    //         foundParticle.x = platform.x + platform.width / 2;
    //     };
    //     if ( platformAnimDuration / 2 === platformAnimFrame) {
    //         foundParticle.y = platform.y;
    //         foundParticle.x = platform.x + platform.width / 2;
    //     }; 
    // };

    function relocateAssests() {
        trambolineContainer.forEach(tramboline => {
            tramboline.x = tramboline.x - tramboline.width;
        });

        coinContainer.forEach(coin => {
            coin.x = coin.x + coin.width / 2;
            coin.y = coin.y - 10;
        });

        enemyContainer.forEach(enemy => {
            enemy.x = enemy.x + 5;
            enemy.y = enemy.y - 30;
            enemy.width = player.width;
            enemy.height =  player.height;    
        });

        boosterContainer.forEach(booster => {
            booster.y = booster.y - 30;
        });

        heartContainer.forEach(heart => {
            heart.y = heart.y - 23; 
        });

        particleContainer.forEach(particle => {
            particle.x = particle.x + particle.width/2;
        });
    };

    function drawTrambolines() {
        trambolineContainer.forEach(tramboline => {
            if (tramboline.tramboline === true) {
                ctx.fillStyle = 'red';
                ctx.fillRect(tramboline.x, tramboline.y - camera.y, tramboline.width, tramboline.height);
            };
        });
    };

    function drawBoosters() {
        boosterContainer.forEach(booster => {
            const svgJetpack = `
                <svg class="icon icon-tabler icon-tabler-jetpack" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M0 0h24v24H0z" fill="none" stroke="none"/>
                    <path d="m10 6a3 3 0 1 0-6 0v7h6v-7z"/>
                    <path d="m14 13h6v-7a3 3 0 0 0-6 0v7z"/>
                    <path d="m5 16c0 2.333 0.667 4 2 5 1.333-1 2-2.667 2-5"/>
                    <path d="m15 16c0 2.333 0.667 4 2 5 1.333-1 2-2.667 2-5"/>
                    <path d="m10 8h4"/>
                    <path d="m10 11h4"/>
                </svg>
            `;
                
            const img = new Image();
            img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgJetpack)}`;
            
            ctx.drawImage(img, booster.x, booster.y - camera.y, assetStats.width, assetStats.height);
        });

    };

    function drawCoins() {
        coinContainer.forEach(coin => {
            ctx.beginPath();
            ctx.arc(coin.x, coin.y - camera.y, coinStats.coinRadius, coinStats.coinStartAngle, coinStats.coinEndAngle);
            ctx.fillStyle = 'yellow';
            ctx.fill();
            ctx.closePath();
        });
    };

    function drawParticles() {

        particleContainer.forEach(particle => {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y - camera.y, particleStats.particleRadius, particleStats.particleStartAngle, particleStats.particleEndAngle);
            ctx.fillStyle = text;
            ctx.fill();
            ctx.closePath();
        });
    };

    function drawEnemies() {
        ctx.fillStyle = text;
        enemyContainer.forEach(enemy => {
            ctx.fillRect(enemy.x, enemy.y - camera.y, enemy.width, enemy.height);
        });
    };

    function drawHearts() {
        heartContainer.forEach(heart => {
            const svgHeart = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="#FF0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C15.09 3.81 16.76 3 18.5 3 21.58 3 24 5.42 24 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            `;

            const img = new Image();
            img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgHeart)}`;

            ctx.drawImage(img, heart.x, heart.y - camera.y, assetStats.width, assetStats.height);
        });
    };

    function rectangularCollisionDetection(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    };

    function platformCollisionDetection(rect1, rect2) {
        return rect1.y + rect1.height / 2 >= rect2.y &&
        rect1.y + rect1.height / 2 <= rect2.y + rect2.height &&
        rect1.x <= rect2.x + rect2.width && rect1.x + rect1.width >= rect2.x;
    };

    function circularCollisionDetection(rect, circle) {
  
        let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
        let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
        
        let distX = circle.x - closestX;
        let distY = circle.y - closestY;
        let distance = Math.sqrt(distX * distX + distY * distY);
        
        return distance <= coinStats.coinRadius;
    };

    function findLowestPlatform() {

        const keyToExclude = ["isMoving", "particle"];
        let filteredContainer = platformContainer
            .filter(obj => !keyToExclude.some(key => obj.hasOwnProperty(key)))

        lowestPlatform = filteredContainer.reduce((lowestPlatform, currentPlatform) => {
            return currentPlatform.y > lowestPlatform.y ? currentPlatform : lowestPlatform; 
         });
    };

    function areEqual(obj1, obj2) {
        if (obj1.id === obj2.id) {
            return true;
        }
        return false;
    };

    function deletePlatform(platform, index) {

        if (platform.enemy === true) {
            platform.enemy = false;
            const foundIndex = enemyContainer.findIndex(enemy => areEqual(enemy, platform));
            enemyContainer.splice(foundIndex, 1);

        } else if (platform.coin === true) {
            platform.coin = false;
            const foundIndex = coinContainer.findIndex(coin => areEqual(coin, platform));
            coinContainer.splice(foundIndex, 1);

        } else if (platform.tramboline === true) {
            platform.tramboline = false;
            const foundIndex = trambolineContainer.findIndex(tramboline => areEqual(tramboline, platform));
            trambolineContainer.splice(foundIndex, 1);

        } else if (platform.booster === true) {
            platform.booster = false;
            const foundIndex = boosterContainer.findIndex(booster => areEqual(booster, platform));
            boosterContainer.splice(foundIndex, 1);

        } else if (platform.heart === true) {
            platform.heart = false;
            const foundIndex = heartContainer.findIndex(heart => areEqual(heart, platform));
            heartContainer.splice(foundIndex, 1);

        } else if (platform.particle === true) {
            platform.particle = false;
            const foundIndex = particleContainer.findIndex(particle => areEqual(particle, platform));
            particleContainer.splice(foundIndex, 1);
        };

        platformContainer.splice(index, 1);
    };

    function deleteAsset(asset, index) {

        if (asset.enemy === true) {
            enemyContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].enemy = false;

        } else if (asset.coin === true) {
            coinContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].coin = false;

        } else if (asset.tramboline === true) {
            trambolineContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].tramboline = false;

        } else if (asset.booster === true) {
            boosterContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].booster = false;

        } else if (asset.heart === true) {
            heartContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].heart = false;
        } else if (asset.heart === true) {
            heartContainer.splice(index, 1);
            const foundIndex = platformContainer.findIndex(platform => areEqual(platform, asset));
            platformContainer[foundIndex].heart = false;
        };
    };

    function respawn() {

        freezePlayer = false;
        isDragging = false;
        trambolineUsed = false;
        player.isFlying = false;
        jumpStrength = 3;
        jumpDuration = 20;
        jumpFrame = 0;

        findLowestPlatform();

        if (lowestPlatform.enemy === true) {
            lowestPlatform.enemy = false;
            const foundIndex = enemyContainer.findIndex(enemy => areEqual(enemy, lowestPlatform));
            enemyContainer.splice(foundIndex, 1);
            enemyContainer.splice(foundIndex, 2);

        } else if (lowestPlatform.coin === true) {
            lowestPlatform.coin = false;
            const foundIndex = coinContainer.findIndex(coin => areEqual(coin, lowestPlatform));
            coinContainer.splice(foundIndex, 1);

        } else if (lowestPlatform.booster === true) {
            lowestPlatform.booster = false;
            const foundIndex = boosterContainer.findIndex(booster => areEqual(booster, lowestPlatform));
            boosterContainer.splice(foundIndex, 1);

        };

        setTimeout(() => {
            player.y = lowestPlatform.y - 50;
            player.x = lowestPlatform.x + player.width;
            spear.x = player.x - spearOffset;
        }, 250);

        lifeLeft --;
    };

    function updateMinValue(newValue) {
        minValue = Math.min(minValue, newValue);
    };

    function updatePlayer() {
        if (minValue - 5 < player.y) {
            camera.y = minValue - canvas.height / 2;
        };
        
        if (!freezePlayer) {
            player.speedY += gravity;
            player.y += player.speedY;
        
            spear.y = player.y - 20;
            
            if (jumpFrame === 100 && trambolineUsed) {
                player.isFlying = false;
                trambolineUsed = false;
            } else if (jumpFrame === 300) {
                player.isFlying = false;
            };
    
            if (player.isJumping && jumpFrame < jumpDuration) {
                player.speedY = -jumpStrength;
                jumpFrame++;
            } else {
                jumpFrame = 0;
                player.isJumping = false;
            };
        };
    };

    startButton.addEventListener('click', () => {
        startButton.classList.add('none');
        interface.classList.remove('none');
        
        isRunning = true;
        
        player.x = (canvas.width / 2) - 7.5;
        player.y = (canvas.height / 2) + 70;
        spear.x = player.x - spearOffset;

        camera.y = 0;
        
        score = 0;
        coinCount = 0;
        enemyCount = 0;

        scoreUI.textContent = `${score}`;

        minValue = Infinity;

        lifeLeft = 3;

        let objectToCopy;
        platformContainer = JSON.parse(JSON.stringify(platforms));
        
        platformContainer.forEach((platform, index) => {
            
            if (platform.coin) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                coinContainer.push(objectToCopy);
            };
            if (platform.enemy) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                enemyContainer.push(objectToCopy);
            };
            if (platform.heart) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                heartContainer.push(objectToCopy);
            };
            if (platform.tramboline) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                trambolineContainer.push(objectToCopy);
            };
            if (platform.booster) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                boosterContainer.push(objectToCopy);
            };
            if (platform.particle) {
                objectToCopy = JSON.parse(JSON.stringify(platform));
                particleContainer.push(objectToCopy);
            };
        });
    
        relocateAssests();
        drawHeartIcons();
        update();
    });
    
    function gameOver() {
        startButton.classList.remove('none');
        startButton.textContent = 'Play Again';
        
        platformContainer = [];
        trambolineContainer = [];
        coinContainer = [];
        enemyContainer = [];
        heartContainer = [];
        boosterContainer = [];
    };

    function update() {

        clearCanvas();
        drawPlayer();
        updatePlayer();
        drawPlatforms();
        drawParticles();
        drawTrambolines();
        drawBoosters();
        drawCoins();
        drawEnemies();
        drawHearts();
        drawHeartIcons();
        updateMinValue(player.y);

        jumpScore = Math.floor((((canvas.height / 2) + 90) - minValue) / 10);
        score = jumpScore + coinCount * 10 + enemyCount * 10;
        scoreUI.textContent = `${score}`;

        camera.x = Math.max(0, Math.min(camera.x, canvas.width - player.width));

        platformContainer.forEach((platform, index) => {
            if (platformCollisionDetection(player, platform) && !player.isFlying && player.isJumping) {
                jumpStrength = 3;
                jumpDuration = 20;
                    
                player.isJumping = true;
                jumpFrame = 0;
                player.speedY = -jumpStrength;
                
                if (platform.breakCount < 3) {

                    platform.breakCount++;
                    if (platform.breakCount === 2) {
                        deletePlatform(platform, index);
                    };
                };
            };
            if (rectangularCollisionDetection(player, platform) && !player.isFlying && !player.isJumping) {
                jumpStrength = 3;
                jumpDuration = 20;
                    
                player.isJumping = true;
                jumpFrame = 0;
                player.speedY = -jumpStrength;
                
                if (platform.breakCount < 3) {
                    
                    platform.breakCount++;
                    if (platform.breakCount === 2) {
                        deletePlatform(platform, index);
                    };
                };
            };
            if ( (camera.height + camera.y) < platform.y) {
                deletePlatform(platform, index);
            };
            if (platform.isMoving) {
                movingPlatformAnim(platform);
            };  
        });

        trambolineContainer.forEach((tramboline, index) => {
            if (platformCollisionDetection(player, tramboline) && !hasCollided) {
                freezePlayer = true;
                hasCollided = true;
                
                setTimeout(() => {
                    freezePlayer = false;
                    trambolineUsed = true;
                    jumpStrength = 5;
                    jumpDuration = 100;
    
                    player.isJumping = true;
                    player.isFlying = true;
                    jumpFrame = 0;
                    player.speedY = -jumpStrength;
                    hasCollided = false;
                }, 400);
            };
            if ( (camera.height + camera.y) < tramboline.y) {
                deleteAsset(tramboline, index);
            };
        });
        
        boosterContainer.forEach((booster, index) => {
            if (rectangularCollisionDetection(player, booster)) {
                jumpStrength = 5;
                jumpDuration = 300;
                
                player.isJumping = true;
                player.isFlying = true;
                jumpFrame = 0;
                player.speedY = -jumpStrength;
                deleteAsset(booster, index);
            };
        });
        
        coinContainer.forEach((coin, index) => {
            if (circularCollisionDetection(player, coin)) {
                coinCount ++;
                deleteAsset(coin, index);
            };
        });
        
        particleContainer.forEach((particle, index) => {
            if (circularCollisionDetection(player, particle)) {
                isRunning = false;
            };
        });

        enemyContainer.forEach((enemy, index) => {
            if (rectangularCollisionDetection(player, enemy)) {
                isRunning = false;
            };
            if (rectangularCollisionDetection(spear, enemy)) {
                enemyCount ++;
                deleteAsset(enemy, index);
            };  
        });

        heartContainer.forEach((heart, index) => {
            if (rectangularCollisionDetection(player, heart)) {
                lifeLeft ++;
                deleteAsset(heart, index);
            };
        });
        
        if ( camera.y + canvas.height < player.y) {
            isRunning = false;
        };
        
        if (isRunning) {
            requestAnimationFrame(update);
        } else {
            cancelAnimationFrame(update);

            if ( lifeLeft > 1 ) { 
                respawn();
                setTimeout(() => {
                    isRunning = true;
                    update();
                }, 250);

            } else {
                gameOver();
            };
        };
    };

</script>