<!DOCTYPE html5>
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena Jumper</title>

<body>
    <section class="container">      
        <canvas id="game-canvas"></canvas>     
        <div class="interface none">
            <div id="health">
                <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
                    <path id="heart-icon" class="none" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/>
                </svg>
            </div>
            <p id="score">0</p>
        </div>
        <button id="start-button">Start</button>
    </section>
</body>

<style>
    @import url('https://fonts.googleapis.com/css2?family=REM:wght@800&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

    body {
        font-family: 'Raleway', sans-serif;
        font-family: 'REM', sans-serif;
        padding: 0;
        margin: 0;
        border: 0;
    }

    :root {
        --text: #0b090a;
        --background: #f8f6f7;
        --primary: #678378;
        --secondary: #e0d7db;
        --accent: #678378;
    }

    .container {
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
    }

    canvas {
        width: 100%;
        height: auto;
        background-color: var(--secondary);
    }
    
    svg {
        width: 100%;
    }

    #heart-icon {
        fill: var(--primary);
    }

    .interface {
        width: 100px;
        height: 50px;
        color: var(--text);
        display: flex;
        flex-direction: column;
        background: none;  
        position: absolute;
        left: 5%;
    }

    #start-button {
        position: absolute;
        background-color: var(--primary);
        color: var(--secondary);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        height: 50px;
        width: 100px;
        font-family: 'REM', sans-serif;
        justify-self: center;
        align-self: center;
        z-index: 1;
    }

    .interface p {
        margin-block: 5px;
    }

    .none {
        display: none;
    }

    </style>

<script>
    
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext("2d");
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const canvasAspectRatio = canvas.width / canvas.height;
    const radius = Math.min(width, height) * 0.025;

    const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary');
    const text = getComputedStyle(document.documentElement).getPropertyValue('--text');

    let score = 0;
    const scoreUI = document.querySelector('#score');

    const heartIcon = document.querySelector('#heart-icon');
    const svg = document.querySelector('svg');
    
    const player = {
        x: (width / 2) - 7.5,
        y: (height / 2) + 70, 
        width: 15,
        height: 30,
        speedX: 0,
        speedY: 0,
        isJumping: false,
    };  
    
    const spear = {
        x: player.x - 7.5,
        y: player.y - 10, 
        width: 5,
        height: 40,
    };

    const camera = {
        y: 0,
        x: 0,
        width: width,
        height: height,
    };

    const moveStrength = 3;
    const jumpStrength = 3;
    const jumpDuration = 20; 
    let jumpFrame = 0; 
    
    const gravity = 0.1;
    
    const platforms = [
        { x: (width / 2) - 14, y: (height / 2) + 90, width: 25, height: 5 },
        { x: (width - 350) / 2, y: (height / 2) + 70, width: 25, height: 5, heart: true },
        { x: (width + 150) / 2, y: (height / 2) - 10, width: 50, height: 5 },
        { x: (width - 75) / 2, y: (height / 2) - 90, width: 25, height: 5, coin: true },
        { x: (width - 400) / 2, y: (height / 2) - 110, width: 25, height: 5 },
        { x: (width + 200) / 2, y: (height / 2) - 130, width: 50, height: 5 },
        { x: (width - 250) / 2, y: (height / 2) - 180, width: 25, height: 5 },
        { x: (width + 100) / 2, y: (height / 2) - 210, width: 25, height: 5, coin: true},
        { x: (width - 35) / 2, y: (height / 2) - 260, width: 25, height: 5 },
        { x: (width - 250) / 2, y: (height / 2) - 280, width: 25, height: 5, enemy: true }, 
        { x: (width + 200) / 2, y: (height / 2) - 310, width: 25, height: 5 },
        // { x: canvas.width + 180, y: -800, width: 50, height: 10 },
        // { x: canvas.width - 180 , y: -800, width: 75, height: 10 },
        // { x: canvas.width + 140, y: -950, width: 50, height: 10 },
        // { x: canvas.width + 35, y: -1100, width: 50, height: 10 },
        // { x: canvas.width - 140, y: -1100, width: 75, height: 10 },
        // { x: canvas.width + 140, y: -1200, width: 50, height: 10 },
        // { x: canvas.width + 250, y: -1300, width: 50, height: 10 },
        // { x: canvas.width - 250, y: -1350, width: 75, height: 10 },
    ];

    const coinStats = {
        coinRadius: radius , coinStartAngle: 0, coinEndAngle: Math.PI * 2
    };

    const heartStats = {
        width: 25, height: 25
    };

    let platformContainer = [];

    let coinContainer = [];

    let enemyContainer = [];
    
    let heartContainer = [];

    const keys = {};
    window.addEventListener('keydown', (event) => {
        keys[event.key] = true;
    });
    
    window.addEventListener('keyup', (event) => {
        keys[event.key] = false;
    });

    let heartLeft = 3;

    function drawHeartIcons() {
        if (heartLeft) {
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }
            for (let index = 0; index < heartLeft; index++) {
                const newIcon = heartIcon.cloneNode(true);
                newIcon.classList.remove('none');
                newIcon.id = 'clone';
                newIcon.setAttribute('transform', `translate(${550 * index - 1350})`);
                svg.appendChild(newIcon);
            };
        }
    };

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    function drawPlayer() {
        ctx.fillStyle = text;
        ctx.fillRect(player.x, player.y - camera.y, player.width, player.height);
        ctx.fillRect(spear.x, spear.y - camera.y, spear.width, spear.height)
    };

    function drawPlatforms() {
        ctx.fillStyle = primary;
        platformContainer.forEach(platform => {
            ctx.fillRect(platform.x, platform.y - camera.y, platform.width, platform.height);
        });
    };

    function drawCoins() {
        coinContainer.forEach(coin => {
            ctx.beginPath();
            ctx.arc(coin.x + coin.width / 2, (coin.y - 10) - camera.y, coinStats.coinRadius, coinStats.coinStartAngle, coinStats.coinEndAngle);
            ctx.fillStyle = primary;
            ctx.fill();
            ctx.closePath();
        })
    };

    function drawEnemies() {
        ctx.fillStyle = text;
        enemyContainer.forEach(enemy => {
            ctx.fillRect(enemy.x + 5, (enemy.y - 30) - camera.y, player.width, player.height);
        });
    };

    function drawHearts() {
        heartContainer.forEach(heart => {

            const svgHeart = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="#FF0000" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C15.09 3.81 16.76 3 18.5 3 21.58 3 24 5.42 24 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            `;

            const img = new Image();
            img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgHeart)}`;

            ctx.drawImage(img, heart.x, (heart.y - 23) - camera.y, heartStats.width, heartStats.height);
        });
    };

    function rectangularCollisionDetection(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    };

    function coinCollisionDetection(rect, circle) {

        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

        const distanceX = circle.x - closestX;
        const distanceY = circle.y - closestY;

        const distanceSquared = distanceX * distanceX + distanceY * distanceY;
        const radiusSquared = coinStats.coinRadius * coinStats.coinRadius;

        if (distanceSquared <= radiusSquared) {

            if (closestX === rect.x || closestX === rect.x + rect.width ||
                closestY === rect.y || closestY === rect.y + rect.height) {
                return true;
            }

            if (distanceSquared <= radiusSquared / 2) {
                return true;
            }

            if (distanceX === 0 && Math.abs(distanceY) <= coinStats.coinRadius ||
                distanceY === 0 && Math.abs(distanceX) <= coinStats.coinRadius) {
                return true;
            }
        }

        return false;
    };

    var lowestPlatform;
    function findLowestPlatform() {
        lowestPlatform = platformContainer.reduce((max, platform) => {
            return platform.y > max ? platform : max; 
        }, -Infinity);
    };

    function deletePlatform(platform1, index) {
        if (platform1.enemy) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteEnemy(index);
        };
        if (platform1.coin) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteCoin(index);
        };
        if (platform1.heart) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteHeart(index);
        };

        platformContainer.splice(index, 1);
    };

    function deleteCoin(index) {
        coinContainer.splice(index, 1);
    };

    function deleteEnemy(index) {
        enemyContainer.splice(index, 1);
    }

    function deleteHeart(index) {
        heartContainer.splice(index, 1);
    }

    function respawn(platform1) {

        if (platform1.enemy) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteEnemy(index);
        };
        if (platform1.coin) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteCoin(index);
        };
        if (platform1.heart) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteHeart(index);
        };

        player.y = platform1.y - 50;
        player.x = platform1.x + 5;
        isRunning = true;

        svg.removeChild(svg.lastElementChild);
    };

    let minValue;

    function updateMinValue(newValue) {
        minValue = Math.min(minValue, newValue);
    };

    let respawnCount = 0;
    var isRunning = false;

    const interface = document.querySelector('.interface');
    const startButton = document.querySelector('#start-button');

    startButton.addEventListener('click', () => {
        startButton.classList.add('none');
        interface.classList.remove('none');
        
        isRunning = true;
        
        player.x = (width / 2) - 7.5;
        player.y = (height / 2) + 70;
        
        score = 0;
        coinCount = 0;
        enemyCount = 0;

        scoreUI.textContent = `${score}`;

        minValue = Infinity;

        heartLeft = 3;

        platforms.forEach(platform => {

            platformContainer.push(platform);
            if (platform.coin) {
                coinContainer.push(platform);
            };
            if (platform.enemy) {
                enemyContainer.push(platform);
            };
            if (platform.heart) {
                heartContainer.push(platform);
            };
        });
        
        drawHeartIcons();
        update();
    });
    
    function gameOver() {
        startButton.classList.remove('none');
        startButton.textContent = 'Play Again';
        
        platformContainer = [];
        
        respawnCount = 0;
    };
    
    let jumpScore = 0;
    let coinCount = 0;
    let enemyCount = 0;

    function update() {
        clearCanvas();
        drawPlayer();
        drawPlatforms();
        drawCoins();
        drawEnemies();
        drawHearts();
        updateMinValue(player.y);

        jumpScore = Math.floor((((height / 2) + 90) - minValue) / 10);
        score = jumpScore + coinCount * 10 + enemyCount * 10;
        scoreUI.textContent = `${score}`;

        player.speedY += gravity;
        
        player.x += player.speedX;
        player.y += player.speedY;

        spear.x = player.x - 7.5;
        spear.y = player.y - 10;

        if (minValue - 5 < player.y) {
            camera.y = minValue - canvas.height / 2;
        };

        if (keys['ArrowLeft']) {
            player.speedX = -moveStrength;

        } else if (keys['ArrowRight']) {
            player.speedX = moveStrength;

        } else {
            player.speedX = 0;
        };
        if (player.x < 7.5) {
            player.x = 7.5;
            spear.x = 0; 
        };
        if (player.x + player.width > canvas.width - 7.5) {
            player.x = canvas.width - player.width;
            spear.x = canvas.width - 22.5;
        };


        platformContainer.forEach(platform => {
            if (rectangularCollisionDetection(player, platform)) {
                player.isJumping = true;
                jumpFrame = 0;
                player.speedY = -jumpStrength;
            }  
        });

        platformContainer.forEach((platform1, index) => {
            if ( (camera.height + camera.y) < platform1.y) {
                deletePlatform(platform1, index);
            }
        });

        coinContainer.forEach((coin, index) => {
            if (coinCollisionDetection(player, coin)) {
                coinCount ++;
                deleteCoin(index);
            }
        });

        enemyContainer.forEach((enemy, index) => {
            if (rectangularCollisionDetection(player, enemy)) {
                isRunning = false;
                respawnCount ++;

                if ( respawnCount < heartLeft ) {
                    respawn(lowestPlatform);
                };
            };
            if (rectangularCollisionDetection(spear, enemy)) {
                enemyCount ++;
                deleteEnemy(index);
            };  
        });

        heartContainer.forEach((heart, index) => {
            if (rectangularCollisionDetection(player, heart)) {
                heartLeft ++;
                drawHeartIcons();
                deleteHeart(index);
            };
        });

        if (player.isJumping && jumpFrame < jumpDuration) {
            player.speedY = -jumpStrength;
            jumpFrame++;
        } else {
            jumpFrame = 0;
            player.isJumping = false;
        }

        if ( camera.y + canvas.height < player.y) {
            isRunning = false;
            respawnCount ++;

            if ( respawnCount < heartLeft ) {
                respawn(lowestPlatform);
                score = 0;
                scoreUI.textContent = `${score}`;
            };
        };

        if (isRunning) {
            requestAnimationFrame(update);
        } else {
            cancelAnimationFrame(update);
            svg.removeChild(svg.lastElementChild);
            gameOver();
        }

        findLowestPlatform();
    };

</script>