<!DOCTYPE html5>
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena Jumper</title>

<body>
    <section class="container">      
        <canvas id="game-canvas"></canvas>     
        <div class="interface none">
            <div id="health">
            </div>
            <p id="score">0</p>
        </div>
        <button id="start-button">Start</button>
    </section>
</body>

<style>
    @import url('https://fonts.googleapis.com/css2?family=REM:wght@800&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

    body {
        font-family: 'Raleway', sans-serif;
        font-family: 'REM', sans-serif;
        padding: 0;
        margin: 0;
        border: 0;
    }

    :root {
        --text: #0b090a;
        --background: #f8f6f7;
        --primary: #678378;
        --secondary: #e0d7db;
        --accent: #678378;
    }

    .container {
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
    }

    canvas {
        width: 100%;
        height: auto;
        background-color: var(--secondary);
    }

    .interface {
        width: 100px;
        height: 50px;
        color: var(--text);
        display: flex;
        flex-direction: column;
        background: none;  
        position: absolute;
        left: 5%;
    }

    #start-button {
        position: absolute;
        background-color: var(--primary);
        color: var(--secondary);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        height: 50px;
        width: 100px;
        font-family: 'REM', sans-serif;
        justify-self: center;
        align-self: center;
        z-index: 1;
    }

    .interface p {
        margin-block: 5px;
    }

    .none {
        display: none;
    }

    </style>

<script>
    
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext("2d");
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const canvasAspectRatio = canvas.width / canvas.height;
    const radius = Math.min(width, height) * 0.025;

    const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary');
    const text = getComputedStyle(document.documentElement).getPropertyValue('--text');

    let score = 0;
    const scoreUI = document.querySelector('#score');
    
    const player = {
        x: (width / 2),
        y: (height / 2) - 40,
        width: 15,
        height: 30,
        speedX: 0,
        speedY: 0,
        isJumping: false,
        radius: Math.sqrt(15 * 30 + 15 * 30) / 2
    };  
    
    const camera = {
        y: 0,
        x: 0,
        width: width,
        height: height,
    };

    const moveStrength = 3;
    const jumpStrength = 3;
    const jumpDuration = 20; 
    let jumpFrame = 0; 
    
    const gravity = 0.1;
    
    const platforms = [
        { x: (width / 2) - 14, y: (height / 2), width: 25, height: 5 },
        { x: (width - 350) / 2, y: (height / 2) - 80, width: 25, height: 5, enemy: true },
        { x: (width + 150) / 2, y: (height / 2) - 100, width: 50, height: 5 },
        { x: (width - 75) / 2, y: (height / 2) - 180, width: 25, height: 5, coin: true, coinRadius: radius , coinStartAngle: 0, coinEndAngle: Math.PI * 2 },
        { x: (width - 400) / 2, y: (height / 2) - 200, width: 25, height: 5 },
        { x: (width + 200) / 2, y: (height / 2) - 220, width: 50, height: 5 },
        { x: (width - 250) / 2, y: (height / 2) - 270, width: 25, height: 5 },
        { x: (width + 100) / 2, y: (height / 2) - 300, width: 25, height: 5, coin: true, coinRadius: radius , coinStartAngle: 0, coinEndAngle: Math.PI * 2 },
        { x: (width - 35) / 2, y: (height / 2) - 350, width: 25, height: 5 },
        { x: (width - 350) / 2, y: (height / 2) - 370, width: 25, height: 5, enemy: true }, 
        { x: (width + 200) / 2, y: (height / 2) - 400, width: 25, height: 5 },
        // { x: canvas.width + 180, y: -800, width: 50, height: 10 },
        // { x: canvas.width - 180 , y: -800, width: 75, height: 10 },
        // { x: canvas.width + 140, y: -950, width: 50, height: 10 },
        // { x: canvas.width + 35, y: -1100, width: 50, height: 10 },
        // { x: canvas.width - 140, y: -1100, width: 75, height: 10 },
        // { x: canvas.width + 140, y: -1200, width: 50, height: 10 },
        // { x: canvas.width + 250, y: -1300, width: 50, height: 10 },
        // { x: canvas.width - 250, y: -1350, width: 75, height: 10 },
    ];

    let platformContainer = [];

    let coinContainer = [];

    let enemyContainer = [];
    
    const keys = {};
    window.addEventListener('keydown', (event) => {
        keys[event.key] = true;
    });
    
    window.addEventListener('keyup', (event) => {
        keys[event.key] = false;
    });

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    function drawPlayer() {
        ctx.fillStyle = text;
        ctx.fillRect(player.x, player.y - camera.y, player.width, player.height);
    };

    function drawPlatforms() {
        ctx.fillStyle = primary;
        platformContainer.forEach(platform => {
            ctx.fillRect(platform.x, platform.y - camera.y, platform.width, platform.height);
        });
    };

    function drawCoins() {
        coinContainer.forEach(coin => {
            ctx.beginPath();
            ctx.arc(coin.x + coin.width / 2, (coin.y - 10) - camera.y, coin.coinRadius, coin.coinStartAngle, coin.coinEndAngle);
            ctx.fillStyle = primary;
            ctx.fill();
            ctx.closePath();
        })
    };

    function drawEnemies() {
        ctx.fillStyle = text;
        enemyContainer.forEach(enemy => {
            ctx.fillRect(enemy.x + 5, (enemy.y - 30) - camera.y, player.width, player.height);
        });
    };

    function platformCollisionDetection(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    };

    function coinCollisionDetection(rect, circle) {

        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

        const distanceX = circle.x - closestX;
        const distanceY = circle.y - closestY;

        const distanceSquared = distanceX * distanceX + distanceY * distanceY;
        const radiusSquared = circle.coinRadius * circle.coinRadius;

        if (distanceSquared <= radiusSquared) {

            if (closestX === rect.x || closestX === rect.x + rect.width ||
                closestY === rect.y || closestY === rect.y + rect.height) {
                return true;
            }

            if (distanceSquared <= radiusSquared / 2) {
                return true;
            }

            if (distanceX === 0 && Math.abs(distanceY) <= circle.coinRadius ||
                distanceY === 0 && Math.abs(distanceX) <= circle.coinRadius) {
                return true;
            }
        }

        return false;
    };

    function enemyCollisionDetection(rect1, rect2) {
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    };

    var lowestPlatform;
    function findLowestPlatform() {
        lowestPlatform = platformContainer.reduce((max, platform) => {
            return platform.y > max ? platform : max; 
        }, -Infinity);
    };

    function deletePlatform(platform1, index) {
        if (platform1.enemy) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteEnemy(index);
        };
        platformContainer.splice(index, 1);
    };

    function deleteCoin(index) {
        coinContainer.splice(index, 1);
    };

    function deleteEnemy(index) {
        enemyContainer.splice(index, 1);
    }

    function respawn(platform1) {

        if (platform1.enemy) {
            let index;
            index = platformContainer.findIndex(platform2 => platform1.x === platform2.x && platform1.y === platform2.y); 
            deleteEnemy(index);
        };

        player.y = platform1.y - 50;
        player.x = platform1.x + 5;
        isRunning = true;
    };

    let minValue = Infinity;

    function updateMinValue(newValue) {
        minValue = Math.min(minValue, newValue);
    };

    let respawnCount = 0;
    var isRunning = false;

    const interface = document.querySelector('.interface');
    const startButton = document.querySelector('#start-button');

    startButton.addEventListener('click', () => {
        startButton.classList.add('none');
        interface.classList.remove('none');
        
        isRunning = true;
        player.x = (width / 2) - 7.5,
        player.y = (height / 2) - 40,
        
        minValue = Infinity;

        platforms.forEach(platform => {

            platformContainer.push(platform);
            if (platform.coin) {
                coinContainer.push(platform);
            } else if (platform.enemy) {
                enemyContainer.push(platform);
            };
        });
        
        update();
    });
    
    function gameOver() {
        startButton.classList.remove('none');
        startButton.textContent = 'Play Again';
        
        platformContainer = [];
        
        respawnCount = 0;
    };
    
    function update() {
        clearCanvas();
        drawPlayer();
        drawPlatforms();
        drawCoins();
        drawEnemies();

        player.speedY += gravity;
        
        player.x += player.speedX;
        player.y += player.speedY;

        camera.y = player.y - canvas.height / 2;

        if (keys['ArrowLeft']) {
            player.speedX = -moveStrength;

        } else if (keys['ArrowRight']) {
            player.speedX = moveStrength;

        } else {
            player.speedX = 0;
        }
        if (player.x < 0) {
            player.x = 0;  
        };
        if (player.x + player.width > canvas.width) {
            player.x = canvas.width - player.width;
        };


        platformContainer.forEach(platform => {
            if (platformCollisionDetection(player, platform)) {
                player.isJumping = true;
                jumpFrame = 0;
                player.speedY = -jumpStrength;
            }  
        });

        coinContainer.forEach((coin, index) => {
            if (coinCollisionDetection(player, coin)) {
                score += 10;
                scoreUI.textContent = `${score}`;
                deleteCoin(index);
            }
        });

        enemyContainer.forEach(enemy => {
            if (enemyCollisionDetection(player, enemy)) {
                isRunning = false;
                respawnCount ++;

                if ( respawnCount < 3 ) {
                    respawn(lowestPlatform);
                };
            }  
        });

        if (player.isJumping && jumpFrame < jumpDuration) {
            player.speedY = -jumpStrength;
            jumpFrame++;
            updateMinValue(player.y);
        } else {
            jumpFrame = 0;
            player.isJumping = false;
        }

        platformContainer.forEach((platform1, index) => {
            if ( (camera.height + camera.y) < platform1.y) {
                deletePlatform(platform1, index);
            }
        });

        if (minValue - ((camera.y - player.y)) < player.y) {
            isRunning = false;
            respawnCount ++;

            if ( respawnCount < 3 ) {
                respawn(lowestPlatform);
            };
        };

        if (isRunning) {
            requestAnimationFrame(update);
        } else {
            cancelAnimationFrame(update);
            gameOver();
        }

        findLowestPlatform();
    };

</script>

<!-- <svg id="original-svg" class="none" width="100" height="100" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 21.35l-1.45-1.32C5.4 16.36 2 12.28 2 7.77 2 4.42 4.42 2 7.77 2c1.74 0 3.41.81 4.5 2.16C13.83 2.81 15.5 2 17.24 2 20.58 2 23 4.42 23 7.77c0 4.51-3.4 8.59-8.55 12.26L12 21.35z" fill="red"/>
</svg> -->